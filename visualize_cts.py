#!/usr/bin/env python3
"""
visualize_cts.py - Visualize Clock Tree Synthesis as H-Tree Diagram
Usage: python visualize_cts.py <design_name> <placement_json>

Shows logical tree structure:
  - CLK at bottom (root)
  - Buffers in middle levels
  - DFFs at top (leaves)
"""

import sys
import json
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from pathlib import Path

def load_data(design_name, placement_file):
    """Load CTS data from eco_generator output"""
    
    # Load CTS data generated by eco_generator
    cts_file = Path(f"build/{design_name}/{design_name}_cts_data.json")
    if not cts_file.exists():
        print(f"ERROR: CTS data file not found: {cts_file}")
        print("Please run eco_generator.py first to generate the CTS data.")
        sys.exit(1)
    
    with open(cts_file) as f:
        cts_data = json.load(f)
    
    # Extract DFFs and clock buffers from CTS data
    dffs = cts_data['dffs']
    clock_buffers = cts_data['clock_buffers']
    
    # Build connections map for visualization
    processed_buffers = []
    for buf in clock_buffers:
        connections = buf.get('connections', {})
        output_net = connections.get('X') or connections.get('Y')
        input_net = connections.get('A')
        
        # Find which DFFs this buffer drives
        driven_dffs = []
        for dff in dffs:
            dff_clk = dff['connections'].get('CLK')
            if dff_clk == output_net:
                driven_dffs.append(dff)
        
        processed_buffers.append({
            'name': buf['name'],
            'site': buf['site'],
            'output_net': output_net,
            'input_net': input_net,
            'drives': driven_dffs
        })
    
    return dffs, processed_buffers

def build_tree_hierarchy(clock_buffers):
    """Build hierarchical tree structure from buffer connections"""
    
    # Find buffers by level based on their net names
    levels = {}
    root_buffers = []
    
    for buf in clock_buffers:
        output_net = buf['output_net']
        input_net = buf['input_net']
        
        # Determine level from net name (clk_L0_B*, clk_L1_B*, etc.)
        if output_net and output_net.startswith('clk_L'):
            try:
                level = int(output_net.split('_')[1][1:])  # Extract number after 'L'
                if level not in levels:
                    levels[level] = []
                levels[level].append(buf)
            except:
                pass
        
        # Root buffer connects directly to 'clk'
        if input_net == 'clk':
            root_buffers.append(buf)
    
    return levels, root_buffers

def visualize_cts(design_name, dffs, clock_buffers):
    """Generate CTS tree visualization - logical H-tree diagram"""
    
    print(f"\n{'='*60}")
    print(f"CTS TREE VISUALIZATION: {design_name}")
    print(f"{'='*60}")
    print(f"DFFs: {len(dffs)}")
    print(f"Clock Buffers: {len(clock_buffers)}")
    
    # Build tree hierarchy
    levels, root_buffers = build_tree_hierarchy(clock_buffers)
    num_levels = max(levels.keys()) + 1 if levels else 1
    
    # Count ACTUAL DFFs driven by clock buffers
    total_dffs_driven = len([dff for buf in clock_buffers for dff in buf['drives']])
    
    print(f"Tree Levels: {num_levels}")
    print(f"Root Buffers: {len(root_buffers)}")
    print(f"DFFs driven: {total_dffs_driven}")
    
    # Create figure with proper aspect ratio for tree
    fig, ax = plt.subplots(figsize=(16, 12))
    
    # Layout parameters - proper tree from bottom to top
    # CLK (bottom) -> L1 (root) -> L0 (leaf buffers) -> DFFs (top)
    y_clk = 0           # CLK at bottom
    y_spacing = 3       # Vertical spacing between levels
    
    # Y positions: CLK -> L1 -> L0 -> DFFs (bottom to top)
    # L1 is the root level (higher number = closer to clock)
    # L0 is the leaf buffer level (drives DFFs)
    y_l1 = y_clk + y_spacing          # Level 1 (root buffers)
    y_l0 = y_l1 + y_spacing           # Level 0 (leaf buffers)  
    y_dff = y_l0 + y_spacing          # DFFs at top
    
    y_levels = {1: y_l1, 0: y_l0}
    
    # Position L0 buffers (spread horizontally at top)
    buffer_positions = {}
    l0_buffers = levels.get(0, [])
    n_l0 = len(l0_buffers)
    l0_width = max(20, n_l0 * 2.5)
    
    for i, buf in enumerate(l0_buffers):
        x = (i - (n_l0 - 1) / 2) * (l0_width / max(1, n_l0 - 1)) if n_l0 > 1 else 0
        buffer_positions[buf['name']] = (x, y_l0)
    
    # Position L1 buffers (root level, centered)
    l1_buffers = levels.get(1, [])
    n_l1 = len(l1_buffers)
    for i, buf in enumerate(l1_buffers):
        x = (i - (n_l1 - 1) / 2) * 3 if n_l1 > 1 else 0
        buffer_positions[buf['name']] = (x, y_l1)
    
    # CLK position
    clk_x = 0
    
    # === DRAW CONNECTIONS ===
    
    # 1. CLK to L1 buffer(s) - vertical green line
    for buf in l1_buffers:
        bx, by = buffer_positions[buf['name']]
        ax.plot([clk_x, bx], [y_clk, by], 'green', linewidth=3, zorder=2)
    
    # 2. L1 to L0 buffers - proper H-tree branching
    # All L0 buffers have input_net = "clk_L1_B0" (output of L1 buffer)
    for l1_buf in l1_buffers:
        l1_x, l1_y = buffer_positions[l1_buf['name']]
        l1_output = l1_buf['output_net']  # e.g., "clk_L1_B0"
        
        # Find all L0 buffers driven by this L1 buffer (their input matches L1's output)
        driven_l0 = [b for b in l0_buffers if b['input_net'] == l1_output]
        
        if driven_l0:
            # Get x positions of driven L0 buffers
            l0_xs = [buffer_positions[b['name']][0] for b in driven_l0]
            min_x, max_x = min(l0_xs), max(l0_xs)
            
            # Draw from L1 UP to horizontal bus, then across, then UP to L0s
            bus_y = (y_l1 + y_l0) / 2
            
            # Vertical from L1 up to bus
            ax.plot([l1_x, l1_x], [l1_y, bus_y], 'orange', linewidth=2.5, zorder=2)
            
            # Horizontal bus spanning all L0 buffers
            ax.plot([min_x, max_x], [bus_y, bus_y], 'orange', linewidth=2.5, zorder=2)
            
            # Vertical lines from bus UP to each L0 buffer
            for l0_buf in driven_l0:
                l0_x, l0_y = buffer_positions[l0_buf['name']]
                ax.plot([l0_x, l0_x], [bus_y, l0_y], 'orange', linewidth=2.5, zorder=2)
    
    # 3. L0 buffers to DFFs - fan-out triangles
    for buf in l0_buffers:
        bx, by = buffer_positions[buf['name']]
        driven_dffs = buf['drives']
        n_dff = len(driven_dffs)
        
        if n_dff == 0:
            continue
        
        # Draw vertical line up from buffer
        ax.plot([bx, bx], [by, by + 0.5], 'blue', linewidth=1.5, zorder=2)
        
        # Fan out to DFFs - spread them above this buffer
        dff_spread = min(2, n_dff * 0.15)
        for j, dff in enumerate(driven_dffs):
            dx = bx + (j - (n_dff - 1) / 2) * (dff_spread / max(1, n_dff - 1)) if n_dff > 1 else bx
            # Draw line from buffer top to DFF
            ax.plot([bx, dx], [by + 0.5, y_dff], 'blue', linewidth=0.8, alpha=0.6, zorder=1)
    
    # === DRAW ELEMENTS ===
    
    # Draw CLK source
    ax.scatter([clk_x], [y_clk], c='green', s=500, marker='s', 
              edgecolors='darkgreen', linewidths=3, zorder=10)
    ax.text(clk_x, y_clk - 0.6, 'CLK', ha='center', va='top', fontsize=14, fontweight='bold', color='darkgreen')
    
    # Draw L1 buffers (root)
    for buf in l1_buffers:
        bx, by = buffer_positions[buf['name']]
        ax.scatter([bx], [by], c='red', s=400, marker='s', 
                  edgecolors='darkred', linewidths=2, zorder=5)
        label = buf['output_net'].replace('clk_', '') if buf['output_net'] else 'ROOT'
        ax.text(bx, by - 0.4, label, ha='center', va='top', fontsize=9, fontweight='bold')
    
    # Draw L0 buffers (leaf)
    for buf in l0_buffers:
        bx, by = buffer_positions[buf['name']]
        ax.scatter([bx], [by], c='red', s=350, marker='s', 
                  edgecolors='darkred', linewidths=2, zorder=5)
        label = buf['output_net'].replace('clk_', '') if buf['output_net'] else buf['name'][:6]
        ax.text(bx, by + 0.4, label, ha='center', va='bottom', fontsize=8, fontweight='bold')
    
    # Draw DFFs as a continuous bar at top
    # Count ACTUAL DFFs driven (from all buffers, not just L0)
    total_dffs = sum(len(buf['drives']) for buf in clock_buffers)
    if l0_buffers:
        all_l0_x = [buffer_positions[b['name']][0] for b in l0_buffers]
        dff_left = min(all_l0_x) - 1.5
        dff_right = max(all_l0_x) + 1.5
        
        # Draw DFF bar
        ax.plot([dff_left, dff_right], [y_dff, y_dff], 'blue', linewidth=8, solid_capstyle='round', zorder=4)
        
        # Draw small circles for individual DFFs
        dff_xs = []
        for buf in l0_buffers:
            bx = buffer_positions[buf['name']][0]
            n_dff = len(buf['drives'])
            dff_spread = min(2, n_dff * 0.15)
            for j in range(n_dff):
                dx = bx + (j - (n_dff - 1) / 2) * (dff_spread / max(1, n_dff - 1)) if n_dff > 1 else bx
                dff_xs.append(dx)
        
        ax.scatter(dff_xs, [y_dff] * len(dff_xs), c='blue', s=30, marker='o', 
                  edgecolors='darkblue', linewidths=0.5, zorder=6)
    
    # === LABELS ===
    label_x = -l0_width/2 - 3
    ax.text(label_x, y_clk, 'Clock\nSource', ha='right', va='center', fontsize=10, style='italic')
    ax.text(label_x, y_l1, 'Level 1\nBuffers', ha='right', va='center', fontsize=10, style='italic')
    ax.text(label_x, y_l0, 'Level 0\nBuffers', ha='right', va='center', fontsize=10, style='italic')
    ax.text(label_x, y_dff, 'DFFs\n(Sinks)', ha='right', va='center', fontsize=10, style='italic')
    
    # Legend
    legend_elements = [
        mpatches.Patch(facecolor='green', edgecolor='darkgreen', label='CLK Source'),
        mpatches.Patch(facecolor='red', edgecolor='darkred', label=f'Clock Buffers ({len(clock_buffers)})'),
        mpatches.Patch(facecolor='blue', edgecolor='darkblue', label=f'DFFs ({total_dffs})'),
    ]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=11)
    
    # Title
    ax.set_title(f'Clock Tree Synthesis (H-Tree) - {design_name}\n'
                f'{len(clock_buffers)} Buffers • {num_levels} Levels • {total_dffs} DFFs',
                fontsize=14, fontweight='bold')
    
    # Axis settings
    ax.set_xlim(-l0_width/2 - 5, l0_width/2 + 5)
    ax.set_ylim(y_clk - 1.5, y_dff + 1.5)
    ax.axis('off')
    
    # Statistics box - show ALL levels
    stats_text = f"H-Tree Statistics:\n"
    stats_text += f"• Clock Source: clk\n"
    stats_text += f"• Tree Levels: {num_levels}\n"
    # Show all levels in hierarchy
    for lvl in sorted(levels.keys(), reverse=True):
        stats_text += f"• L{lvl} Buffers: {len(levels[lvl])}\n"
    stats_text += f"• Total DFFs: {total_dffs}\n"
    stats_text += f"• Max Fanout: 16"
    
    ax.text(0.02, 0.02, stats_text, transform=ax.transAxes,
           fontsize=10, verticalalignment='bottom',
           bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.9, edgecolor='gray'))
    
    plt.tight_layout()
    
    # Save figure
    output_dir = Path(f"build/{design_name}")
    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / f"{design_name}_cts_tree.png"
    plt.savefig(output_file, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"\n✓ Saved: {output_file}")
    
    plt.close()
    
    # Print buffer details
    print(f"\nClock Buffer Details:")
    for lvl in sorted(levels.keys(), reverse=True):
        print(f"\n  Level {lvl}:")
        for buf in levels[lvl]:
            n_driven = len(buf['drives'])
            driven_type = "DFFs" if buf['output_net'].startswith('clk_L0') else "buffers"
            print(f"    {buf['name']}: {buf['output_net']} -> {n_driven} {driven_type}")
    
    print(f"\n{'='*60}")
    print(f"✓ Visualization Complete!")
    print(f"{'='*60}\n")

def main():
    if len(sys.argv) != 3:
        print("Usage: python visualize_cts.py <design_name> <placement_json>")
        sys.exit(1)
    
    design_name = sys.argv[1]
    placement_file = sys.argv[2]
    
    dffs, clock_buffers = load_data(design_name, placement_file)
    visualize_cts(design_name, dffs, clock_buffers)

if __name__ == "__main__":
    main()
